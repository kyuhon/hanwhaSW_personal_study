08.18 제네릭, Collection


제네릭스는 컬렉션을 위한 도구
ArrayList, HashMap
프레임워크 Collection -> 인터페이스 map<K,V>  => index x
ArrayList 
	동적배열로 배열의 개수가 주어진 크기보다 더 들어가면 배열의 크기가 늘어난다
	쓰레드간 동기화가 지원되지 않는다
	조회 기능이 뛰어남
List<String> stringList = new ArrayList<>();
	필수는 아니지만 관례상 컬렉션은 다형성을 주로 적용
compareTo -> 코테에서는 자주 사용하지만 보통 db에서 order by 를 이용해서 정렬
vector() -> 동기화 처리에 용이, 톰켓에서 기본적인 동기화를 처리해서 나중에 고급개발자로서 리소스를 깎을 때 사용
제네릭에 기본자료형은 사용불가, 참조자료형만 가능





확인사항
09:30 와일드카드
09:41 reptile
09:45 상한제한과 하한제한 erd설명
10:06 순회라는 말의 정의
10:16 ArrayList 장점
10:19 list의 동적바인딩
10:23 ArrayList 스레드간 동기화
10:30 interface List
10:40 compareTo
10:45 LinkedList의 메소드를 사용해서 내림차순 학습
	생성자 호출을 ArrayList에서 LinkedList로 변경
10:48 Iterator를 무언가로 비유한 부분
11:10 제네릭을 적용하면 iter.next() 반환형이 명확해짐(타입안정성)
11:20 implements Comparable<BookDTO> -> compareTo @Override
11:45~ Comparable 인터페이스를 구현한 해당 클래스 기준 정렬 외에도 Comparator를 구현한 별도의 정렬 기준도 가능
	  List게열도 sort 메소드를 사용할 수 있으며 Comparator를 구현한 인스턴스 여부만 판단하면 된다.
12:30 Queue<T> que = new LinkedList();
12:40 max, min 힙정렬 - 트리구조
12:48 단축키?? , 임포트가 유지보수 측면에서 좋다??
14:03 힙정렬관련 트리... (코드한줄)
15:00 ~ 15:45 Collection자바 해석 순대
15:50 HashMap



하부르타

제네릭
	객체 타입은 상하 관계가 있지만 제네릭 타입은 상하관계가 없다
	객체를 이용할 때는 캐스팅이 가능해서 효율적으로 작성할 수 있지만
	제네릭의 타입 파라미터끼리는 캐스팅이 불가능하기 때문에 제네릭을 사용해서
	효율적으로 코드를 작성할 수 있다

	와일드카드
		트럼프 카드 게임에서 어떤 카드로도 취급될 수 있는 카드/조커
		자바에서는 *는 0개 이상의 문자와 매칭, ?는 1개의 문자와 매칭
		데이터베이스에서는 like연산자에서 %가 0개 이상의 문자, _ 1개의 문자

	<?> : 어떤 타입이든 허용 (unbounded wildcard)
	<? extends Number> : Number 또는 그 하위 타입만 허용 (상한 제한, upper bound)
		읽기전용
	<? super Integer> : Integer 또는 그 상위 타입만 허용 (하한 제한, lower bound)
		쓰기전용
			코드 작성 중에 컴파일에러가 나는걸 확인함으로써 런타임 에러가 나는걸 막음
Collection 프레임워크

	 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현

Comparator과 Comparable
	Comparator
		객체를 비교해서 정렬 순서를 결정
	Comparable
		객체 자체에 자연 순서를 정의

List 인터페이스
	Collection의 하위 인터페이스
	ArrayList a = new ArrayList();
		ArrayList 전용 기능을 사용할 수 있지만 다른 구현체로 교체 불가하고 유연성이 떨어짐
	List a = new ArrayList();
		구현체 교체가 용이하고 다형성 활용하고 유지보수성이 오름
		solid원칙 중 인터페이스 분리원칙과 의존성 역전원칙에 부합
		ArrayList 전용 메서드는 사용 불가

ArrayList
	동적배열로 배열의 개수가 주어진 크기보다 더 들어가면 배열의 크기가 늘어난다
	쓰레드간 동기화가 지원되지 않는다
	조회 기능이 뛰어남

	Application1
		Iterator<String> iter = ((LinkedList<String>) stringList).descendingIterator();
     		   while (iter.hasNext()) {
          		  System.out.print(iter.next() + " ");    // 제네릭을 적용하면 iter.next() 반환형이 명확해짐(타입안정성)
        		}
		

	Application2
		bookList.sort(null);
		if (c == null) {
 		   // 요소가 Comparable을 구현하고 있다고 가정하고 natural order로 정렬
  		  Arrays.sort((Object[]) list.toArray());
		} else {
  			  // Comparator 사용
		}

Set 인터페이스
	중복을 허용하지 않음
		

	HashSet

	LinkdedHashSet

	TreeSet