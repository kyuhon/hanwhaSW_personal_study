09.05 스프링 어노테이션

@Service
@Autowired

마이바티스와 스프링 마이바티스
ResultSet은 소모성

Mockito

di 전용 라이브러리
	@Resouce
	@Inject


생성자 주입의 이점
1. 필드에 final 키워드를 사용할 수 있다(오염 방지)
2. 순환 참조를 스프링 시작(컨테이너 생성 시)과 동시에 확인하고 에러를 발생시켜 준다
3. field 주입 및 setter 주입의 단점을 보완
	(필드 주입은 간결하지만 남용할 수 있고 이후에 setter가 없이는 수정이 불가능하다)
	(setter 주입은 불변 객체를 만들고자 함에 있어 문제가 발생할 수 있으면 정말 필요한 객체의 속성
	변경을 위해서만 setter를 추가하는 것이 맞다(feat. 가급적 변경의 여지를 남기지 않아야 한다.))
4. 테스트 코드 작성이 용이하다.(생성자 주입은 @InjectMocks를 사용하지 않고 그 자리에서 객체를 생성해서 쉽게 할 수 있음)

확인사항
09:21 클래스 객체간의 연결 (BookDAO, BookDAOImpl)
09:40 BookService bookService = context.getBean("setterService" , bookService.class); 설명부분
10:05 ResultSet은 소모성과 부가설명
10:12 필드주입 - 리플렉션 기술
10:23 리플렉션 기술 설명, BookDAO타입의 빈 객체를 생성자를 통해 주입 받는다(기본 생성자 사용 X)
10:27 순환참조, 스택오버플로우(생성자를 계속 호출)
10:32 불변객체와 안티패턴의 문제 야기점
필드주입을 테스트코드에서 하기도 하다
10:42 @autowired 필드,세터,생성자
10:43 MVC Model2 **********************
12:04 forEach 의 biconsumer형으로 사용
12:08 di 전용 라이브러리, mapter나 seter가 안되고 안되는 경우가 있다
14:49 DI와는 별개로 외부 리소스로부터 키값을 활용해 밸류를 불러와 변수에 대입이 가능
	1. 코드 상에서 실제 대입되는 값을 숨길 수 있음
	2. 외부 리소스 수정을 통해 서버가 중단되지 않고도 값이 수정될 수 있다.

하부르타

MVC Model2
	MVC패턴은 디자인 패턴 중 하나로 model, view, controller의 앞글자를 따서 만든 패턴
	컨트롤러는 사용자의 요청을 수신하고 그에 맞는 비즈니스 로직을 수행
	비즈니스 로직을 수행하면서 컨트롤러는 필요에 따라 모델을 호출하여 데이터를 요청
	요청을 모두 처리하면 뷰를 통해 사용자가 원하는 정보를 시각화

	mvc패턴은 크게 2종류로 나눈다
	mvc모델 1은 뷰와 컨트롤러의 역할이 합쳐져있어서 jsp에 자바코드와 html,css등의 코드가
	섞여 있어 소스가 복잡해지고 읽기가 어려워짐

	개선하기 위한 모델이 mvc모델 2로 jsp는 뷰의 역할만 하고 컨트롤러 역할을 Servlet이 수행해서
	mvc1에서는 jsp가 사용자의 호출을 받았는데 mvc2에서는 컨트롤러 역할을 수행해서 Servlet이 요청을 받음


	servlet

	@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws IOException {
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();

        // HTML을 직접 출력해야 함
        out.println("<html>");
        out.println("<body>");
        out.println("<h1>Hello, Servlet!</h1>");
        out.println("</body>");
        out.println("</html>");
    }
}


	jsp

<%@ page contentType="text/html;charset=UTF-8" %>
<html>
  <body>
    <h1>Hello, JSP!</h1>
    <% 
        // 자바 코드도 넣을 수 있음
        String name = "건일";
        out.println("<p>반가워요, " + name + "!</p>");
    %>
  </body>
</html>


리플렉션 기술
	리플렉션 - 런타임에 클래스/메서드/필드를 동적으로 다루는 기술
	자바와 같은 객체지향 언어에서 런타임에 특정 클래스나 객체에 대한 정보를 동적으로
	검사하고 조작할 수 있게 해주는 기능
	BookDAO타입의 빈 객체를 생성자를 통해 주입
		매개변수 작성 쪽에 new 키워드 대신 class.newInstance()같은 방식으로 객체 생성
	의존성 주입(Dependency Injection)
	@Autowired를 쓰면 스프링은 리플렉션을 이용해서 해당 필드나 생성자에 접근
		

순환참조와 스택 오버플로우 연결
	순환참조: 객체/모듈이 서로를 참조하는 관계 -> 메모리 누수나 설계 복잡성 문제
	스택 오버플로우: 함수 호출 스택이 넘쳐서 생기는 런타임 오류 -> 잘못된 재귀에서 발생

class A {
    B b;
    public String toString() {
        return "A with " + b; // b.toString() 호출
    }
}

class B {
    A a;
    public String toString() {
        return "B with " + a; // a.toString() 호출
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();
        a.b = b;
        b.a = a;

        System.out.println(a); // 무한 toString 호출 → StackOverflowError
    }
}

Mockito
	단위 테스트를 위해 모의 객체를 생성하고 관리하는 데 사용되는 자바 오픈소스 프레임워크
	실제 객체의 동작을 모방하고 모의객체를 생성하여 코드의 '특정 부분을 격리'시키고
	테스트하기 쉽게 만듬

어노테이션
	소스 코드에 메타데이터, 즉 추가 정보를 주석처럼 달아, 컴파일러나 다른 프로그램에게
	유용한 정보를 전달하는 기술
	메타데이터: 코드 자체의 동작에 직접 영향을 주지 않지만 코드에 대한 부가적인 정보를 제공
	프로그램의 동작 방식에 영향을 주지는 않지만, 컴파일 시점의 검사, 개발 도구를 통한
	코드 자동 생성, 런타임 시 특정 기능을 수행하도록 정보를 제공하는 용도로 활용

@Controller
	스프링 mvc의 컨트롤러 클래스

@Service
	비즈니스 로직을 처리하는 계층
	컨트롤러와 DAO 사이에서 데이터를 가공하거나 처리하는 역할
	스프링이 해당 클래스를 빈으로 등록해서 다른 곳에서 주입가능

@Repository
	DAO계층에서 사용
	스프링이 자동으로 예외 변환(AOP)을 해줌 -> DB 관련 예외를 스프링 예외로 바꿔줌

@Autowired
	의존성 주입을 자동으로 해주는 어노테이션
	의존 객체 탐색 순서
		필드나 파라미너 타입과 같은 빈을 스프링 컨테이너에서 찾는다
		빈이 여러 개일 경우 변수명이나 파라미터 이름과 같은 빈을 주입
		타입이 중복 문제가 발생하면 @Qualifier를 사용해서 어떤 빈을 주입할지 지정
		여러 후보 빈이 존재할 경우 특정 빈에 @Primary를 붙여서 기본 주입 대상으로 설정 가능

파라미터 함수 정의 시 설정되는 변수로, 특정 동작이나 결과에 영향을 주는 값을 의미

@RequestMapping
	URL요청을 특정 메서드나 클래스와 매핑하는 어노테이션

@Qulifier
	사용할 의존 객체를 선택할 수 있도록 해준다
@Bean
	스프링 프레임워크에서 스프링 컨테이너가 관리해야 할 객체를 직접 정의할 때 사용
		스프링이 @Configuration이 붙은 클래스를 읽음
		@Bean이 붙은 매서드를 실행해서 객체생성
		반환된 객체를 스프링 컨테이너에 등록
		다른 곳에서 @Autowired나 @Inject 등을 통해 주입받아 사용 가능

	@Component와 차이점
		@Component: 클래스에 붙여서 스프링이 자동으로 스캔(컴포넌트 스캔) 해서 Bean으로 등록
		@Bean: 개발자가 직접 Bean을 정의해야 할 때 사용
			외부 라이브러리 객체를 Bean으로 등록할 때 유용
		

@Configuration
	xml 설정(applicationContext.xml)을 대체하는 용도로 사용
	
	@Bean 메서드들로 구성된 설정 클래스로 정의
		동작방식
		스프링이 @Configuration이 붙은 클래스를 읽음
		@Bean이 붙은 메서드를 실행해서 객체 생성
		반환된 객체를 스프링 컨테이너에 등록
		다른 곳에서 @Autowired나 @Inject등을 통해 주입받아 사용 가능
			@Bean 메서드가 여러 번 호출되어도 실제로는 스프링 컨테이너가 관리하는 단일 인스턴스

@PropertySource
	.PropertySource를 이용해서 .properties파일을 불러올 수 있음

@Value
	스프링에서 값(리터럴, 프로퍼티 값, SpEL 표현식 등)을 필드나 메서드 파라미터에 주입할 때
	사용하는 어노테이션

di 전용 라이브러리
	@Resouce
	@Inject


형규

의존성 주입
	필드,세터,생성자 주입

resource 필드주입만 가능
insject
